



from DeepJetCore.TrainData import TrainData, fileTimeOut
import numpy 

class TrainData_fractions(TrainData):
    def __init__(self):
        TrainData.__init__(self)

        self.treename="Delphes" #input root tree name
        
        self.truthclasses=[] #truth classes for classification
        
        self.weightbranchX='isA' #needs to be specified if weighter is used
        self.weightbranchY='isB' #needs to be specified if weighter is used
        
        #there is no need to resample/reweight
        self.weight=False
        self.remove=False
        #does not do anything in this configuration
        self.referenceclass='flatten'
        self.weight_binX = numpy.array([0,40000],dtype=float) 
        self.weight_binY = numpy.array([0,40000],dtype=float) 
        
        
        #self.registerBranches(['']) #list of branches to be used 
        
        self.registerBranches(self.truthclasses)
        
        
        #call this at the end
        self.reduceTruth(None)
        
    
    def readFromRootFile(self,filename,TupleMeanStd, weighter):
    
        # this function defines how to convert the root ntuple to the training format
        # options are not yet described here
        
        import ROOT
        fileTimeOut(filename,120) #give eos a minute to recover
        rfile = ROOT.TFile(filename)
        tree = rfile.Get(self.treename)
        self.nsamples=tree.GetEntries()
        
        max_rechits = 40000
        
        # user code, example works with the example 2D images in root format generated by make_example_data
        from DeepJetCore.preprocessing import  readListArray
        
        feature_array = readListArray(filename,
                                      self.treename,
                                      "rechit_features",
                                      self.nsamples,
                                      list_size=max_rechits, 
                                      n_feat_per_element=7,
                                      zeropad=True)
        
        
        energy_only = feature_array[:,:,0:1]#keep dimension
        
        
        fraction_array = readListArray(filename,
                                       self.treename,
                                       "simcluster_fractions",
                                       self.nsamples,
                                      list_size=max_rechits, 
                                      n_feat_per_element=7,#nsimcluster, right now just one, but zero-padded here
                                      zeropad=True)
        
        
        #needs the energy, too to determine weights
        fraction_array = numpy.concatenate([fraction_array,energy_only],axis=-1)
        #in case something was removed here
        self.nsamples=len(feature_array)
        
        self.x=[feature_array] 
        self.y=[fraction_array] # we need the features also in the truth part for weighting
        self.w=[] # no event weights


